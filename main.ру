import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ï–†–í–ï–† –î–õ–Ø –°–¢–ê–¢–£–°–ê LIVE ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
# –ö–†–ò–¢–ò–ß–ù–û: —Å–æ–∑–¥–∞–µ–º client –î–û —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)

# –ü–∞–º—è—Ç—å –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–µ–π –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–º
last_notified_msg = {}

async def get_ai_response(dots, history):
    if dots >= 5:
        style = "VIP-–∫–ª–∏–µ–Ω—Ç. –ü–∏—à–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ, –≤–µ–∂–ª–∏–≤–æ –∏ —É–±–µ–¥–∏—Ç–µ–ª—å–Ω–æ. –ó–∞–∫—Ä–æ–π —Å–¥–µ–ª–∫—É."
    elif dots >= 3:
        style = "–î–µ–ª–æ–≤–æ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç. –ß–µ—Ç–∫–æ, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ, –ø–æ —Ñ–∞–∫—Ç–∞–º."
    else:
        style = "–ö—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç. 1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, —Å–∞–º–∞—è —Å—É—Ç—å."

    prompt = f"–¢—ã ‚Äî –ê–∞—Ä–æ–Ω, —ç–∫—Å–ø–µ—Ä—Ç –≤ –ü–∞—Ç—Ç–∞–π–µ (—Ä—ã–±–∞–ª–∫–∞, –±–∞–π–∫–∏, –≤–∏–∑—ã). {style}"
    messages = [{"role": "system", "content": prompt}]
    
    for msg in history:
        role = "assistant" if msg.out else "user"
        content = msg.text.replace('.', '') if msg.text else ""
        messages.append({"role": role, "content": content})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=messages)
        return completion.choices[0].message.content
    except:
        return "–°–µ–π—á–∞—Å —É—Ç–æ—á–Ω—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –æ—Ç–≤–µ—á—É –≤–∞–º..."

@client.on(events.NewMessage)
async def handler(event):
    try:
        if not event.is_private: return
        
        sender = await event.get_sender()
        text = event.raw_text if event.raw_text else ""
        chat_id = event.chat_id

        # 1. –¢–í–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ß–ï–†–ï–ó –¢–û–ß–ö–ò
        if event.out:
            dot_count = text.count('.')
            if 1 <= dot_count <= 10:
                history = await client.get_messages(chat_id, limit=10)
                ai_reply = await get_ai_response(dot_count, history[::-1])
                await asyncio.sleep(2)
                await event.respond(ai_reply)
        
        # 2. –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –í –ò–ó–ë–†–ê–ù–ù–û–ï (–ë–ï–ó –î–£–ë–õ–ï–ô)
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –ª–∏ –º—ã —É–∂–µ —Ç–∞–∫–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            if last_notified_msg.get(chat_id) != text:
                last_notified_msg[chat_id] = text
                user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={sender.id}"
                
                await client.send_message('me', 
                    f"üì© **–ù–û–í–û–ï –í –õ–ò–ß–ö–ï**\n"
                    f"üë§: {sender.first_name}\n"
                    f"üí¨: {text}\n\n"
                    f"üîó {user_link}")

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –ë–û–¢ LIVE. –£–ü–†–ê–í–õ–ï–ù–ò–ï –¢–û–ß–ö–ê–ú–ò –í–ö–õ–Æ–ß–ï–ù–û")
    await client.run_until_disconnected()

if __name__ == '__main__':
    client.loop.run_until_complete(main())
