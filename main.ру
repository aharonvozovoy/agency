import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ï–†–í–ï–† LIVE ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)
dialog_history = {}

# –¢–≤–æ–π —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∑–Ω–∞–∫ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –±–æ—Ç–∞ –≤ –ª–∏—á–∫–µ
BOT_TRIGGER = "üòâ" 

# –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è –ò–ò
WORK_PROMPT = "–¢—ã ‚Äî –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: —Ä—ã–±–∞–ª–∫–∞, —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã, –±–∞–π–∫–∏. –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ, –¥—Ä—É–∂–µ–ª—é–±–Ω–æ, —Å–æ —Å–º–∞–π–ª–∏–∫–∞–º–∏. –ó–∞–∫—Ä—ã–≤–∞–π –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ –≤—Å—Ç—Ä–µ—á—É –∏–ª–∏ —Å–æ–∑–≤–æ–Ω."
GIRLS_PROMPT = "–¢—ã ‚Äî —Ö–∞—Ä–∏–∑–º–∞—Ç–∏—á–Ω—ã–π –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ, —É–∂–∏–Ω, –ø—Ä–æ–≥—É–ª–∫–∏. –ü–∏—à–∏ –≥–∞–ª–∞–Ω—Ç–Ω–æ, —Å –ª–µ–≥–∫–∏–º —Ñ–ª–∏—Ä—Ç–æ–º üòâ. –¢–≤–æ—è —Ü–µ–ª—å ‚Äî –¥–æ–≥–æ–≤–æ—Ä–∏—Ç—å—Å—è –æ –≤—Å—Ç—Ä–µ—á–µ."

async def get_ai_response(user_id, user_text, is_girl_request, history_context=None):
    prompt = GIRLS_PROMPT if is_girl_request else WORK_PROMPT
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–≤—è–∑–Ω–æ—Å—Ç–∏
    messages = [{"role": "system", "content": prompt}]
    if history_context:
        for msg in history_context:
            role = "assistant" if msg.out else "user"
            messages.append({"role": role, "content": msg.text})
    
    messages.append({"role": "user", "content": user_text})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=messages)
        return completion.choices[0].message.content
    except:
        return "–î–∞–≤–∞–π –≤ –ª–∏—á–∫–µ –æ–±—Å—É–¥–∏–º, —Ç–∞–∫ —É–¥–æ–±–Ω–µ–µ –±—É–¥–µ—Ç! ;)"

@client.on(events.NewMessage)
async def handler(event):
    try:
        sender = await event.get_sender()
        if not sender: return
        text = event.raw_text
        
        # 1. –†–∞–±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–∞—Ö (–õ–æ–≤–ª—è –ª–∏–¥–æ–≤)
        if not event.is_private:
            is_girl = any(w in text.lower() for w in ['—É–∂–∏–Ω', '—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é', '–≤–µ—á–µ—Ä'])
            is_work = any(w in text.lower() for w in ['—Ä—ã–±–∞–ª–∫–∞', '—Ç–∞–∫—Å–∏', '–±–∞–π–∫', '–≤–∏–∑–∞'])
            
            if (is_girl or is_work) and len(text) < 300:
                ai_reply = await get_ai_response(sender.id, text, is_girl)
                await asyncio.sleep(3)
                await event.reply(ai_reply)

        # 2. –£–º–Ω–∞—è –ª–∏—á–∫–∞ (–ü–µ—Ä–µ—Ö–≤–∞—Ç –¥–∏–∞–ª–æ–≥–∞)
        elif event.is_private:
            # –ï—Å–ª–∏ –¢–´ –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–º–∞–π–ª–∏–∫-—Ç—Ä–∏–≥–≥–µ—Ä
            if event.out and text.strip() == BOT_TRIGGER:
                # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                history = await client.get_messages(event.chat_id, limit=5)
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                is_girl = any("üíé" in m.text for m in history if m.out)
                
                ai_reply = await get_ai_response(sender.id, "–ü—Ä–æ–¥–æ–ª–∂–∏ –¥–∏–∞–ª–æ–≥ –∑–∞ –º–µ–Ω—è", is_girl, history[::-1])
                await asyncio.sleep(2)
                await event.respond(ai_reply)
            
            # –ï—Å–ª–∏ –ø–∏—à–µ—Ç –ö–õ–ò–ï–ù–¢ (–±–æ—Ç —É–≤–µ–¥–æ–º–ª—è–µ—Ç —Ç–µ–±—è)
            elif not event.out:
                user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={sender.id}"
                await client.send_message('me', f"üì© **–ù–û–í–û–ï –í –õ–ò–ß–ö–ï!**\nüë§: {sender.first_name}\nüí¨: {text}\n\nüîó {user_link}")

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –ì–ò–ë–†–ò–î–ù–´–ô –ë–û–¢ –° –ü–ï–†–ï–•–í–ê–¢–û–ú –ó–ê–ü–£–©–ï–ù")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
