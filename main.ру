import os
import asyncio
from telethon import TelegramClient
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading

# ТВОИ НОВЫЕ ДАННЫЕ СО СКРИНШОТА
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
PHONE = '+79870346313'

# Код подтверждения берем из переменной TG_CODE в Render
TG_CODE = os.environ.get('TG_CODE')

client = TelegramClient('session_aaron', API_ID, API_HASH)

# Заглушка для порта (чтобы Render не выдавал ошибку "No open ports")
def run_port_server():
    try:
        server = HTTPServer(('0.0.0.0', 10000), type('H', (BaseHTTPRequestHandler,), {'do_GET': lambda s: (s.send_response(200), s.end_headers())}))
        server.serve_forever()
    except: pass

async def main():
    print("--- ЗАПУСК С НОВЫМИ КЛЮЧАМИ ---")
    await client.connect()

    if not await client.is_user_authorized():
        # Если в Render еще нет кода, запрашиваем его
        if not TG_CODE or TG_CODE.strip() == "":
            print(">>> ЗАПРОС КОДА: Отправляю код в Telegram...")
            try:
                await client.send_code_request(PHONE)
                print("✅ КОД ОТПРАВЛЕН! Проверь телефон.")
            except Exception as e:
                print(f"❌ Ошибка запроса: {e}")
        else:
            # Если ты уже вписал код в Render, входим
            try:
                print(f">>> ПРОБУЮ ВОЙТИ С КОДОМ: {TG_CODE}")
                await client.sign_in(PHONE, TG_CODE.strip())
                print("✅✅✅ УСПЕХ! Аарон активен.")
            except Exception as e:
                print(f"❌ Ошибка входа: {e}")
                print("Совет: Очисти TG_CODE в Render и попробуй снова.")
    else:
        print("✅ СТАТУС: Бот уже авторизован!")

    while True: await asyncio.sleep(1000)

if __name__ == '__main__':
    threading.Thread(target=run_port_server, daemon=True).start()
    asyncio.run(main())
