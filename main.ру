import os
import asyncio
import threading
import http.server
import socketserver
import imaplib
import smtplib
import email
import time
from email.mime.text import MIMEText
import telethon # <--- Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ñ‚Ð²Ð¾ÑŽ Ð¾ÑˆÐ¸Ð±ÐºÑƒ ÑÐ¾ ÑÐºÑ€Ð¸Ð½Ð°
from telethon import TelegramClient, events, errors # <--- Ð”Ð¾Ð±Ð°Ð²Ð¸Ð»Ð¸ errors
from groq import Groq

# ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ WhatsApp, ÐµÑÐ»Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑÑ
try:
    from whatsapp_api_client_python import API
    WA_AVAILABLE = True
except:
    WA_AVAILABLE = False
# --- 1. HEALTH CHECK Ð”Ð›Ð¯ RENDER ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- 2. ÐšÐžÐÐ¤Ð˜Ð“Ð£Ð ÐÐ¦Ð˜Ð¯ ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

# WhatsApp (Green-API) - ÐšÐ»ÑŽÑ‡Ð¸ Ð¿Ð¾ÑÐ²ÑÑ‚ÑÑ Ð¿Ð¾ÑÐ»Ðµ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸
ID_INSTANCE = os.environ.get('WA_ID_INSTANCE')
API_TOKEN_INSTANCE = os.environ.get('WA_API_TOKEN')

# Gmail
EMAIL_USER = os.environ.get('EMAIL_USER')
EMAIL_PASS = os.environ.get('EMAIL_PASS')
EMAIL_IMAP = "imap.gmail.com"
EMAIL_SMTP = "smtp.gmail.com"

ai_client = Groq(api_key=GROQ_KEY)
tg_client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)

dialog_history = {}

# --- 3. Ð›ÐžÐ“Ð˜ÐšÐ Ð˜ ÐŸÐ ÐžÐœÐŸÐ¢Ð« ---
WORK_KEYWORDS = ['Ñ€Ñ‹Ð±Ð°Ð»ÐºÐ°', 'fishing', 'Ð´Ð¸Ð·Ð°Ð¹Ð½', 'Ð»Ð¾Ð³Ð¾Ñ‚Ð¸Ð¿', 'Ñ‚Ð°ÐºÑÐ¸', 'Ð°ÑÑ€Ð¾Ð¿Ð¾Ñ€Ñ‚']
GIRLS_KEYWORDS = ['ÑÐ¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸ÑŽ', 'ÑÐºÑƒÑ‡Ð½Ð¾', 'Ð¿Ñ€Ð¾Ð³ÑƒÐ»ÐºÐ°', 'ÑƒÐ¶Ð¸Ð½', 'Ð²ÐµÑ‡ÐµÑ€']

WORK_PROMPT = "Ð¢Ñ‹ â€” Ð¿Ð¾Ð¼Ð¾Ñ‰Ð½Ð¸Ðº ÐÐ°Ñ€Ð¾Ð½. Ð£ÑÐ»ÑƒÐ³Ð¸: Ñ€Ñ‹Ð±Ð°Ð»ÐºÐ°, Ð´Ð¸Ð·Ð°Ð¹Ð½. Ð¤Ñ€Ð°Ð·Ð°: 'Ð˜Ñ‰Ñƒ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð¾Ðº (Ð½ÑƒÐ¶Ð½Ñ‹ Ð´ÐµÐ½ÑŒÐ³Ð¸)'."
GIRLS_PROMPT = "Ð¢Ñ‹ â€” Ð³Ð°Ð»Ð°Ð½Ñ‚Ð½Ñ‹Ð¹ ÐÐ°Ñ€Ð¾Ð½. Ð£ÑÐ»ÑƒÐ³Ð¸ ÑÐ¾Ð¿Ñ€Ð¾Ð²Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ. Ð¤Ñ€Ð°Ð·Ð°: 'ÐŸÑ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÑŽ ÑƒÑÐ»ÑƒÐ³Ð¸ Ð½Ð° ÐºÐ¾Ð¼Ð¼ÐµÑ€Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¾ÑÐ½Ð¾Ð²Ðµ'."

async def get_ai_response(user_id, user_text):
    text_l = user_text.lower()
    is_girl = any(word in text_l for word in GIRLS_KEYWORDS)
    prompt = GIRLS_PROMPT if is_girl else WORK_PROMPT
    
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": prompt}]
    dialog_history[user_id].append({"role": "user", "content": user_text})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=dialog_history[user_id])
        ai_text = completion.choices[0].message.content
        return ai_text, is_girl
    except:
        return "ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð“Ð¾Ñ‚Ð¾Ð² Ð¾Ð±ÑÑƒÐ´Ð¸Ñ‚ÑŒ Ð´ÐµÑ‚Ð°Ð»Ð¸, Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ!", is_girl

# --- 4. ÐžÐ‘Ð ÐÐ‘ÐžÐ¢Ð§Ð˜Ðš WHATSAPP (Green-API) ---
def wa_loop():
    if not WA_AVAILABLE or not ID_INSTANCE:
        print("âš ï¸ WhatsApp Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½ (Ð½ÐµÑ‚ ÐºÐ»ÑŽÑ‡ÐµÐ¹ Ð¸Ð»Ð¸ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸)")
        return
    
    wa_api = API.GreenApi(ID_INSTANCE, API_TOKEN_INSTANCE)
    print("ðŸ“² WhatsApp Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½")
    while True:
        try:
            receive = wa_api.receiving.receiveNotification()
            if receive.body:
                receipt_id = receive.body['receiptId']
                data = receive.body.get('messageData', {})
                chat_id = receive.body['senderData']['chatId']
                
                if 'textMessageData' in data:
                    text = data['textMessageData']['textMessage']
                    reply, _ = asyncio.run(get_ai_response(chat_id, text))
                    wa_api.sending.sendMessage(chat_id, reply)
                
                wa_api.receiving.deleteNotification(receipt_id)
        except:
            time.sleep(5)

# --- 5. ÐžÐ‘Ð ÐÐ‘ÐžÐ¢Ð§Ð˜Ðš GMAIL ---
def email_loop():
    if not EMAIL_USER or not EMAIL_PASS:
        print("âš ï¸ ÐŸÐ¾Ñ‡Ñ‚Ð° Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð° (Ð½ÐµÑ‚ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐº)")
        return
        
    print("ðŸ“§ Gmail Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½")
    while True:
        try:
            mail = imaplib.IMAP4_SSL(EMAIL_IMAP)
            mail.login(EMAIL_USER, EMAIL_PASS)
            mail.select("inbox")
            _, data = mail.search(None, 'UNSEEN')
            for num in data[0].split():
                _, msg_data = mail.fetch(num, '(RFC822)')
                msg = email.message_from_bytes(msg_data[0][1])
                sender = email.utils.parseaddr(msg['From'])[1]
                subject = msg['Subject'] or ""
                reply_text, _ = asyncio.run(get_ai_response(sender, subject))
                
                with smtplib.SMTP_SSL(EMAIL_SMTP, 465) as smtp:
                    smtp.login(EMAIL_USER, EMAIL_PASS)
                    resp = MIMEText(reply_text)
                    resp['Subject'] = "Re: " + subject
                    resp['To'] = sender
                    resp['From'] = EMAIL_USER
                    smtp.sendmail(EMAIL_USER, sender, resp.as_string())
        except:
            time.sleep(30)

# --- 6. ÐžÐ‘Ð ÐÐ‘ÐžÐ¢Ð§Ð˜Ðš TELEGRAM ---
@tg_client.on(events.NewMessage)
async def handle_tg(event):
    if event.out: return
    try:
        sender = await event.get_sender()
        reply, is_girl = await get_ai_response(sender.id, event.raw_text)
        await asyncio.sleep(2)
        await event.respond(reply)
        
        tag = "ðŸ’Ž VIP (TG)" if is_girl else "ðŸ›  Ð—ÐÐšÐÐ— (TG)"
        await tg_client.send_message('me', f"ðŸ”¥ **{tag}**\nðŸ‘¤: {sender.first_name}\nðŸ’¬: {event.raw_text}")
    except errors.rpcerrorlist.SlowModeWaitErrorSlowModeWaitError:
        print("âš ï¸ Ð’ Ñ‡Ð°Ñ‚Ðµ Ð¼ÐµÐ´Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼, Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÑŽ...")
    except Exception as e:
        print(f"ÐžÑˆÐ¸Ð±Ð¾Ñ‡ÐºÐ°: {e}")

# --- 7. Ð—ÐÐŸÐ£Ð¡Ðš ---
if __name__ == '__main__':
    threading.Thread(target=wa_loop, daemon=True).start()
    threading.Thread(target=email_loop, daemon=True).start()
    print("ðŸš€ Ð‘ÐžÐ¢ Ð—ÐÐŸÐ£Ð¡ÐšÐÐ•Ð¢Ð¡Ð¯...")
    tg_client.start()
    tg_client.run_until_disconnected()
