import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ï–†–í–ï–† –î–õ–Ø –°–¢–ê–¢–£–°–ê LIVE ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)
dialog_history = {}

# –í–µ—Ç–∫–∞ 1: –û–±—â–∏–µ —É—Å–ª—É–≥–∏ (–ë–ï–ó –î–ò–ó–ê–ô–ù–ê)
WORK_KEYWORDS = ['—Ä—ã–±–∞–ª–∫–∞', 'fishing', '—Ç–∞–∫—Å–∏', '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–±–∫–∫', '—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä', '–±–∞–π–∫', '–≤–∏–∑–∞', 'visa']
# –í–µ—Ç–∫–∞ 2: –î–ª—è –¥–µ–≤—É—à–µ–∫ (VIP —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ)
GIRLS_KEYWORDS = ['—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é', '—Å–∫—É—á–Ω–æ', '–∏—â—É –ø–∞—Ä–Ω—è', '–ø—Ä–æ–≥—É–ª–∫–∞', '—É–∂–∏–Ω', '–≤–µ—á–µ—Ä', '–≤–º–µ—Å—Ç–µ', '–ø—Ä–æ–π—Ç–∏—Å—å']

BAD_WORDS = ['–∏—Å–ø–∞–Ω–∏—è', '–µ–≤—Ä–æ–ø–∞', '–∞—Ä–±–∏—Ç—Ä–∞–∂', '—Ç—Ä–∞—Ñ–∏–∫', 'crypto', '–≤–∞–ª—é—Ç–∞', '–¥–∏–∑–∞–π–Ω', '–ª–æ–≥–æ—Ç–∏–ø']

# –¢–µ–∫—Å—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–æ—Å—è—Ç –¥–µ–Ω—å–≥–∏
WORK_PROMPT = "–¢—ã ‚Äî –ê–∞—Ä–æ–Ω, –ø—Ä–æ—Ñ–∏ –≤ –ü–∞—Ç—Ç–∞–π–µ. –£—Å–ª—É–≥–∏: —Ä—ã–±–∞–ª–∫–∞, —Ç–∞–∫—Å–∏, –≤–∏–∑—ã. –ü–∏—à–∏: '–ü—Ä–∏–≤–µ—Ç! –Ø –≤ –ü–∞—Ç—Ç–∞–π–µ, –ø–æ–º–æ–≥—É —Å —ç—Ç–∏–º –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. –°–¥–µ–ª–∞—é –≤—Å—ë —á–µ—Ç–∫–æ. –ù–∞–ø–∏—à–∏—Ç–µ –≤ –ª–∏—á–∫—É, –æ–±—Å—É–¥–∏–º!'"
GIRLS_PROMPT = "–¢—ã ‚Äî –≥–∞–ª–∞–Ω—Ç–Ω—ã–π –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: –∫–æ–º–ø–∞–Ω–∏—è –¥–ª—è –¥–∞–º, —É–∂–∏–Ω, –ø—Ä–æ–≥—É–ª–∫–∏. –ü–∏—à–∏: '–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä! –ö–∞–∫ —Ä–∞–∑ —Å–≤–æ–±–æ–¥–µ–Ω –¥–ª—è –ø—Ä–∏—è—Ç–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏. –ó–Ω–∞—é –ª—É—á—à–∏–µ –º–µ—Å—Ç–∞ –≤ –≥–æ—Ä–æ–¥–µ, —Å–æ –º–Ω–æ–π –±—É–¥–µ—Ç –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ. –ù–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–∫—É?'"

async def get_ai_response(user_id, user_text, is_girl_request):
    prompt = GIRLS_PROMPT if is_girl_request else WORK_PROMPT
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": prompt}]
    dialog_history[user_id].append({"role": "user", "content": user_text})
    completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=dialog_history[user_id])
    ai_text = completion.choices[0].message.content
    dialog_history[user_id].append({"role": "assistant", "content": ai_text})
    return ai_text

@client.on(events.NewMessage)
async def handler(event):
    try:
        if event.out: return 
        sender = await event.get_sender()
        if not sender: return
        text = event.raw_text.lower()
        
        is_girl_req = any(word in text for word in GIRLS_KEYWORDS)
        is_work_req = any(word in text for word in WORK_KEYWORDS)
        is_bad = any(bad in text for bad in BAD_WORDS)

        if not event.is_private and (is_girl_req or is_work_req) and not is_bad:
            ai_reply = await get_ai_response(sender.id, event.raw_text, is_girl_req)
            await asyncio.sleep(3)
            await event.reply(ai_reply)

        elif event.is_private:
            ai_reply = await get_ai_response(sender.id, event.raw_text, is_girl_req)
            await asyncio.sleep(2)
            await event.respond(ai_reply)
            user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={sender.id}"
            tag = "üíé VIP –î–ï–í–£–®–ö–ê" if is_girl_req else "üõ† –ó–ê–ö–ê–ó"
            await client.send_message('me', f"üî• **{tag} –í –õ–ò–ß–ö–ï!**\n\nüë§: {sender.first_name}\nüí¨: {event.raw_text}\nü§ñ: {ai_reply}\n\nüîó **–û–¢–ö–†–´–¢–¨:** {user_link}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –û–•–û–¢–ù–ò–ö –ó–ê –ó–ê–ö–ê–ó–ê–ú–ò –í –ü–ê–¢–¢–ê–ô–ï –ó–ê–ü–£–©–ï–ù")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
