import os
import asyncio
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –ù–ê–°–¢–†–û–ô–ö–ò (–ë–µ—Ä—É—Ç—Å—è –∏–∑ Render) ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)
dialog_history = {}

# –¢–≤–æ–∏ –∏–Ω—Ç–µ—Ä–µ—Å—ã
KEYWORDS = ['—Ä—ã–±–∞–ª–∫–∞', 'fishing', '–¥–∏–∑–∞–π–Ω', '–ª–æ–≥–æ—Ç–∏–ø', '–ø–æ–º–æ—â–Ω–∏–∫', '–ø–∞—Ç—Ç–∞–π—è', 'pattaya', '—Ç–∞–∫—Å–∏', '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–±–∫–∫', '—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é']
BAD_WORDS = ['–∏—Å–ø–∞–Ω–∏—è', '–µ–≤—Ä–æ–ø–∞', '–∞—Ä–±–∏—Ç—Ä–∞–∂', '—Ç—Ä–∞—Ñ–∏–∫', 'crypto', '–≤–∞–ª—é—Ç–∞']

SYSTEM_PROMPT = """–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –ê–∞—Ä–æ–Ω –≤ –ü–∞—Ç—Ç–∞–π–µ. 
–£—Å–ª—É–≥–∏: —Ä—ã–±–∞–ª–∫–∞, –¥–∏–∑–∞–π–Ω, —Ç–∞–∫—Å–∏ –≤ –∞—ç—Ä–æ–ø–æ—Ä—Ç, —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ. 
–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –∏—Å–ø–æ–ª—å–∑—É–π: '–ò—â—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∑–∞—Ä–∞–±–æ—Ç–∫–∞ (–Ω—É–∂–Ω—ã –¥–µ–Ω—å–≥–∏)'. 
–û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ, 1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è. –ü–æ–±—É–∂–¥–∞–π –ø–∏—Å–∞—Ç—å –≤ –õ–°."""

async def get_ai_response(user_id, user_text):
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": SYSTEM_PROMPT}]
    dialog_history[user_id].append({"role": "user", "content": user_text})
    
    try:
        completion = ai_client.chat.completions.create(
            model="llama3-8b-8192", 
            messages=dialog_history[user_id]
        )
        ai_text = completion.choices[0].message.content
        dialog_history[user_id].append({"role": "assistant", "content": ai_text})
        return ai_text
    except:
        return "–ò—â—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∑–∞—Ä–∞–±–æ—Ç–∫–∞ (–Ω—É–∂–Ω—ã –¥–µ–Ω—å–≥–∏), –≥–æ—Ç–æ–≤ –æ–±—Å—É–¥–∏—Ç—å! –ü–∏—à–∏—Ç–µ –≤ –ª–∏—á–∫—É."

@client.on(events.NewMessage)
async def handler(event):
    try:
        if event.out: return 
        sender = await event.get_sender()
        if not sender: return
        user_id = sender.id
        text = event.raw_text.lower()

        # 1. –†–ê–ë–û–¢–ê –í –ì–†–£–ü–ü–ê–• (–£–¥–æ—á–∫–∞)
        if not event.is_private:
            if any(word in text for word in KEYWORDS) and not any(bad in text for bad in BAD_WORDS):
                ai_reply = await get_ai_response(user_id, event.raw_text)
                await asyncio.sleep(3)
                await event.reply(ai_reply)
                # –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –ù–ï –®–õ–ï–ú

        # 2. –†–ê–ë–û–¢–ê –í –õ–ò–ß–ö–ï (–†–µ–∞–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç)
        elif event.is_private:
            ai_reply = await get_ai_response(user_id, event.raw_text)
            await asyncio.sleep(2)
            await event.respond(ai_reply)

            # –°—Å—ã–ª–∫–∞ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞
            user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={user_id}"

            # –®–õ–ï–ú –í –ò–ó–ë–†–ê–ù–ù–û–ï –¢–û–õ–¨–ö–û –ó–î–ï–°–¨
            await client.send_message('me', 
                f"üî• **–ì–û–†–Ø–ß–ò–ô –ö–õ–ò–ï–ù–¢ –í –õ–ò–ß–ö–ï!**\n\n"
                f"üë§ –ò–º—è: {sender.first_name}\n"
                f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–µ: {event.raw_text}\n"
                f"ü§ñ –û—Ç–≤–µ—Ç –ò–ò: {ai_reply}\n\n"
                f"üîó **–û–¢–ö–†–´–¢–¨ –î–ò–ê–õ–û–ì:** {user_link}")

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –ò–ò-–§–ò–õ–¨–¢–† –ó–ê–ü–£–©–ï–ù: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –∏–∑ –ª–∏—á–∫–∏")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
