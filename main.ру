import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ò–°–¢–ï–ú–ê LIVE ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
# –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç client –ü–ï–†–ï–î –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤ –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–∞—Ö
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)

async def get_ai_response(relevance_level, history):
    # –õ–æ–≥–∏–∫–∞ —É—Ä–æ–≤–Ω–µ–π —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–≤–æ–∏—Ö —Ç–æ—á–µ–∫
    if relevance_level >= 5:
        instruction = "–≠—Ç–æ VIP –∫–ª–∏–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ, –æ—á–µ–Ω—å –≤–µ–∂–ª–∏–≤–æ –∏ —ç–∫—Å–ø–µ—Ä—Ç–Ω–æ. –ó–∞–∫—Ä–æ–π —Å–¥–µ–ª–∫—É."
    elif relevance_level >= 3:
        instruction = "–î–µ–ª–æ–≤–æ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç. –ß–µ—Ç–∫–∏–π, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ —Å—É—â–µ—Å—Ç–≤—É."
    else:
        instruction = "–ö—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç. 1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –º–∏–Ω–∏–º—É–º –≤–æ–¥—ã."

    prompt = f"–¢—ã ‚Äî –ê–∞—Ä–æ–Ω, –ø—Ä–æ—Ñ–∏ –≤ –ü–∞—Ç—Ç–∞–π–µ. {instruction} –¢–µ–º—ã: —Ä—ã–±–∞–ª–∫–∞, –±–∞–π–∫–∏, –≤–∏–∑—ã, —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã."
    
    messages = [{"role": "system", "content": prompt}]
    for msg in history:
        role = "assistant" if msg.out else "user"
        # –£–±–∏—Ä–∞–µ–º —Ç–≤–æ–∏ —Ç—Ä–∏–≥–≥–µ—Ä–Ω—ã–µ —Ç–æ—á–∫–∏ –∏–∑ –ø–∞–º—è—Ç–∏ –ò–ò, —á—Ç–æ–±—ã –æ–Ω –Ω–µ —Å–ø–∞–º–∏–ª –∏–º–∏ —Å–∞–º
        content = msg.text.replace('.', '') if msg.text else ""
        messages.append({"role": role, "content": content})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=messages)
        return completion.choices[0].message.content
    except:
        return "–°–µ–∫—É–Ω–¥—É, —Å–≤–µ—Ä—è—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É..."

@client.on(events.NewMessage)
async def handler(event):
    try:
        if not event.is_private: return
        
        sender = await event.get_sender()
        text = event.raw_text
        
        # –ê–∫—Ç–∏–≤–∞—Ü–∏—è –ò–ò —Ç–æ–ª—å–∫–æ –Ω–∞ –¢–í–û–ò –∏—Å—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ç–æ—á–∫–∞–º–∏
        if event.out:
            dot_count = text.count('.') # –°—á–∏—Ç–∞–µ–º —Ç–æ—á–∫–∏ –≤ —Ç–≤–æ–µ–º —Ç–µ–∫—Å—Ç–µ
            
            # –ï—Å–ª–∏ —Ç—ã –ø–æ—Å—Ç–∞–≤–∏–ª –æ—Ç 1 –¥–æ 5 —Ç–æ—á–µ–∫ (–∏ –±–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –∏–ª–∏ –∫–æ—Ä–æ—Ç–∫—É—é —Ñ—Ä–∞–∑—É)
            if 1 <= dot_count <= 10:
                history = await client.get_messages(event.chat_id, limit=10)
                
                ai_reply = await get_ai_response(dot_count, history[::-1])
                
                await asyncio.sleep(2) # –≠—Ñ—Ñ–µ–∫—Ç –ø–µ—á–∞—Ç–∞–Ω–∏—è
                await event.respond(ai_reply)
                
                # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–µ
                await client.send_message('me', f"‚úÖ **–ò–ò –û–¢–í–ï–¢–ò–õ (–£—Ä–æ–≤–µ–Ω—å: {dot_count})**\n–î–ª—è: {sender.first_name}")

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ: {e}")

async def main():
    await client.start()
    print("üöÄ –ë–û–¢ –ó–ê–ü–£–©–ï–ù –ò –ì–û–¢–û–í –ö –†–ê–ë–û–¢–ï –° –¢–û–ß–ö–ê–ú–ò")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
