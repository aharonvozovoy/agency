import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ò–°–¢–ï–ú–ê –ü–û–î–î–ï–†–ñ–ö–ò –°–¢–ê–¢–£–°–ê LIVE (–ß—Ç–æ–±—ã Render –Ω–µ –≤—ã–∫–ª—é—á–∞–ª –±–æ—Ç–∞) ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ù–ê–°–¢–†–û–ô–ö–ò –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)
dialog_history = {}

# --- –ö–õ–Æ–ß–ï–í–´–ï –°–õ–û–í–ê –î–õ–Ø –ü–ê–¢–¢–ê–ô–ò ---
# –í–µ—Ç–∫–∞ 1: –£—Å–ª—É–≥–∏ –∏ –ª–æ–≥–∏—Å—Ç–∏–∫–∞ (–¥–µ–Ω—å–≥–∏ –Ω–∞ –∫–æ–º–∏—Å—Å–∏–∏ –∏ —Å–µ—Ä–≤–∏—Å–µ)
WORK_KEYWORDS = ['—Ä—ã–±–∞–ª–∫–∞', 'fishing', '—Ç–∞–∫—Å–∏', '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–±–∫–∫', '—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä', '–±–∞–π–∫', '–≤–∏–∑–∞', 'visa', '–ª–æ–¥–∫–∞', '–∫–∞—Ç–µ—Ä']
# –í–µ—Ç–∫–∞ 2: VIP-—Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ (–¥–µ–Ω—å–≥–∏ –∑–∞ –ª–∏—á–Ω–æ–µ –≤—Ä–µ–º—è)
GIRLS_KEYWORDS = ['—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é', '—Å–∫—É—á–Ω–æ', '–∏—â—É –ø–∞—Ä–Ω—è', '–ø—Ä–æ–≥—É–ª–∫–∞', '—É–∂–∏–Ω', '–≤–µ—á–µ—Ä', '–≤–º–µ—Å—Ç–µ', '–ø—Ä–æ–π—Ç–∏—Å—å', '–∫—Ç–æ —Å–≤–æ–±–æ–¥–µ–Ω']

# –ò—Å–∫–ª—é—á–∞–µ–º –º—É—Å–æ—Ä –∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤
BAD_WORDS = ['–∏—Å–ø–∞–Ω–∏—è', '–µ–≤—Ä–æ–ø–∞', '–∞—Ä–±–∏—Ç—Ä–∞–∂', '—Ç—Ä–∞—Ñ–∏–∫', 'crypto', '–≤–∞–ª—é—Ç–∞', '–¥–∏–∑–∞–π–Ω', '–ª–æ–≥–æ—Ç–∏–ø', '—É–¥–∞–ª–µ–Ω–∫–∞']

# --- –ü–†–û–î–ê–Æ–©–ò–ï –ò–ù–°–¢–†–£–ö–¶–ò–ò –î–õ–Ø –ò–ò ---
WORK_PROMPT = """–¢—ã ‚Äî –ê–∞—Ä–æ–Ω, –Ω–∞–¥–µ–∂–Ω—ã–π —á–µ–ª–æ–≤–µ–∫ –≤ –ü–∞—Ç—Ç–∞–π–µ. –¢–≤–æ–∏ —É—Å–ª—É–≥–∏: –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è —Ä—ã–±–∞–ª–∫–∏, —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã –∏ –ø–æ–º–æ—â—å —Å –±–∞–π–∫–∞–º–∏/–≤–∏–∑–∞–º–∏. 
–¢–≤–æ–π –æ—Ç–≤–µ—Ç: '–ü—Ä–∏–≤–µ—Ç! –Ø –≤ –ü–∞—Ç—Ç–∞–π–µ, –º–æ–≥—É –≤–∑—è—Ç—å —ç—Ç–æ –Ω–∞ —Å–µ–±—è –∏ –ø–æ–º–æ—á—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. –°–¥–µ–ª–∞—é –≤—Å—ë —á–µ—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É. –ù–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–∫—É, –æ–±—Å—É–¥–∏–º!'"""

GIRLS_PROMPT = """–¢—ã ‚Äî –≥–∞–ª–∞–Ω—Ç–Ω—ã–π –∏ —Ö–∞—Ä–∏–∑–º–∞—Ç–∏—á–Ω—ã–π –ê–∞—Ä–æ–Ω. –¢—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ—à—å —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ –¥–ª—è –¥–∞–º: —É–∂–∏–Ω—ã, –ø—Ä–æ–≥—É–ª–∫–∏ –ø–æ –ª—É—á—à–∏–º –º–µ—Å—Ç–∞–º –∏ –∫–æ–º–ø–∞–Ω–∏—è. 
–¢–≤–æ–π –æ—Ç–≤–µ—Ç: '–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä! –ö–∞–∫ —Ä–∞–∑ —Å–≤–æ–±–æ–¥–µ–Ω –¥–ª—è –æ—Ç–ª–∏—á–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏. –ó–Ω–∞—é —Å–∞–º—ã–µ –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –º–µ—Å—Ç–∞ –≤ –≥–æ—Ä–æ–¥–µ, —Å–æ –º–Ω–æ–π –±—É–¥–µ—Ç –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ. –ó–∞–≥–ª—è–Ω–∏—Ç–µ –≤ –ª–∏—á–∫—É?'"""

async def get_ai_response(user_id, user_text, is_girl_request):
    prompt = GIRLS_PROMPT if is_girl_request else WORK_PROMPT
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": prompt}]
    
    dialog_history[user_id].append({"role": "user", "content": user_text})
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=dialog_history[user_id])
        ai_text = completion.choices[0].message.content
        dialog_history[user_id].append({"role": "assistant", "content": ai_text})
        return ai_text
    except:
        return "–ù–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤ –ª–∏—á–∫—É, –≥–æ—Ç–æ–≤ –æ–±—Å—É–¥–∏—Ç—å –¥–µ—Ç–∞–ª–∏!"

@client.on(events.NewMessage)
async def handler(event):
    try:
        if event.out: return 
        sender = await event.get_sender()
        if not sender: return
        text = event.raw_text.lower()
        
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è
        is_girl_req = any(word in text for word in GIRLS_KEYWORDS)
        is_work_req = any(word in text for word in WORK_KEYWORDS)
        is_bad = any(bad in text for bad in BAD_WORDS)

        # –†–∞–±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–∞—Ö
        if not event.is_private and (is_girl_req or is_work_req) and not is_bad:
            ai_reply = await get_ai_response(sender.id, event.raw_text, is_girl_req)
            await asyncio.sleep(2) # –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
            await event.reply(ai_reply)

        # –†–∞–±–æ—Ç–∞ –≤ –ª–∏—á–∫–µ (–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —Ç–µ–±—è)
        elif event.is_private:
            ai_reply = await get_ai_response(sender.id, event.raw_text, is_girl_req)
            await event.respond(ai_reply)
            
            user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={sender.id}"
            tag = "üíé VIP –î–ï–í–£–®–ö–ê" if is_girl_req else "üõ† –ó–ê–ö–ê–ó"
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–±–µ –≤ "–ò–∑–±—Ä–∞–Ω–Ω–æ–µ"
            await client.send_message('me', f"üî• **{tag} –í –õ–ò–ß–ö–ï!**\n\nüë§: {sender.first_name}\nüí¨: {event.raw_text}\nü§ñ: {ai_reply}\n\nüîó **–û–¢–ö–†–´–¢–¨:** {user_link}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –î–ï–ù–ï–ñ–ù–´–ô –ë–û–¢ –ó–ê–ü–£–©–ï–ù")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
