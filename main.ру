import os
import asyncio
import threading
import http.server
import socketserver
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# --- –°–ï–†–í–ï–† LIVE –î–õ–Ø RENDER ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

ai_client = Groq(api_key=GROQ_KEY)
client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)

# –¢–í–û–ô –°–ï–ö–†–ï–¢–ù–´–ô –ó–ù–ê–ö (–≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è)
BOT_TRIGGER = "..." 

# –ò–ù–°–¢–†–£–ö–¶–ò–ò –î–õ–Ø –ò–ò (–î–µ–ª–æ–≤–æ–π —Å—Ç–∏–ª—å –ü–∞—Ç—Ç–∞–π–∏)
WORK_PROMPT = "–¢—ã ‚Äî –ê–∞—Ä–æ–Ω, —ç–∫—Å–ø–µ—Ä—Ç –≤ –ü–∞—Ç—Ç–∞–π–µ. –¢–≤–æ–∏ —Ç–µ–º—ã: —Ä—ã–±–∞–ª–∫–∞, —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã, –±–∞–π–∫–∏, –≤–∏–∑—ã. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ, –±–µ–∑ –ª–∏—à–Ω–∏—Ö —Å–º–∞–π–ª–æ–≤. –¶–µ–ª—å ‚Äî –¥–æ–≥–æ–≤–æ—Ä–∏—Ç—å—Å—è –æ –¥–µ—Ç–∞–ª—è—Ö –∏–ª–∏ –≤—Å—Ç—Ä–µ—á–µ."
GIRLS_PROMPT = "–¢—ã ‚Äî —Ö–∞—Ä–∏–∑–º–∞—Ç–∏—á–Ω—ã–π –ê–∞—Ä–æ–Ω. –¢–µ–º–∞: –∫–æ–º–ø–∞–Ω–∏—è, —É–∂–∏–Ω—ã, –ø—Ä–æ–≥—É–ª–∫–∏. –û—Ç–≤–µ—á–∞–π –≥–∞–ª–∞–Ω—Ç–Ω–æ –∏ —É–≤–µ—Ä–µ–Ω–Ω–æ. –¶–µ–ª—å ‚Äî –Ω–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É."

async def get_ai_response(user_text, is_girl, history):
    prompt = GIRLS_PROMPT if is_girl else WORK_PROMPT
    messages = [{"role": "system", "content": prompt}]
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    for msg in history:
        role = "assistant" if msg.out else "user"
        if msg.text and BOT_TRIGGER not in msg.text: # –ù–µ –∫–æ—Ä–º–∏–º –ò–ò —Å–∞–º–∏–º —Ç—Ä–∏–≥–≥–µ—Ä–æ–º
            messages.append({"role": role, "content": msg.text})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=messages)
        return completion.choices[0].message.content
    except:
        return "–î–∞–≤–∞–π—Ç–µ –æ–±—Å—É–¥–∏–º –¥–µ—Ç–∞–ª–∏, —è –Ω–∞ —Å–≤—è–∑–∏."

@client.on(events.NewMessage)
async def handler(event):
    try:
        sender = await event.get_sender()
        if not sender: return
        text = event.raw_text

        # 1. –ì–†–£–ü–ü–´: –õ–æ–≤–∏–º –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
        if not event.is_private:
            is_work = any(w in text.lower() for w in ['—Ä—ã–±–∞–ª–∫–∞', '—Ç–∞–∫—Å–∏', '–±–∞–π–∫', '–≤–∏–∑–∞', '—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä'])
            is_girl = any(w in text.lower() for w in ['–∫–æ–º–ø–∞–Ω–∏—è', '—É–∂–∏–Ω', '–≤–µ—á–µ—Ä', '–ø—Ä–æ–≥—É–ª–∫–∞'])
            
            if (is_work or is_girl) and "..." not in text:
                ai_reply = await get_ai_response(text, is_girl, [])
                await asyncio.sleep(2)
                await event.reply(ai_reply)

        # 2. –õ–ò–ß–ö–ê: –¢–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ "..."
        elif event.is_private:
            # –ï—Å–ª–∏ –¢–´ –Ω–∞–ø–∏—Å–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ —Å "..."
            if event.out and BOT_TRIGGER in text:
                # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –ò–ò –ø–æ–Ω–∏–º–∞–ª, –æ —á–µ–º —Ä–µ—á—å
                history = await client.get_messages(event.chat_id, limit=10)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–µ–≤—É—à–∫–∞ –ª–∏ —ç—Ç–æ (–ø–æ —Ç–µ–≥–∞–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ –∏–ª–∏ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º)
                is_girl_context = any("üíé" in m.text for m in history if m.out)
                
                ai_reply = await get_ai_response("–ü—Ä–æ–¥–æ–ª–∂–∏ –¥–∏–∞–ª–æ–≥", is_girl_context, history[::-1])
                await asyncio.sleep(2) # –ü–∞—É–∑–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
                await event.respond(ai_reply)
            
            # –ï—Å–ª–∏ –ø–∏—à–µ—Ç –ö–õ–ò–ï–ù–¢ (—É–≤–µ–¥–æ–º–ª—è–µ–º —Ç–µ–±—è –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–µ)
            elif not event.out:
                user_link = f"https://t.me/{sender.username}" if hasattr(sender, 'username') and sender.username else f"tg://user?id={sender.id}"
                tag = "üõ† –ó–ê–ö–ê–ó" if "–±–∞–π–∫" in text.lower() or "—Ç–∞–∫—Å–∏" in text.lower() else "üì© –õ–ò–ß–ö–ê"
                await client.send_message('me', f"üî• **{tag}: –û–¢–í–ï–¢!**\nüë§: {sender.first_name}\nüí¨: {text}\n\nüîó {user_link}")

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

async def main():
    await client.start()
    print("üöÄ –ì–ò–ë–†–ò–î–ù–´–ô –ë–û–¢ (–¢–†–ò–ì–ì–ï–† '...') –ó–ê–ü–£–©–ï–ù")
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
