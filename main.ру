import os
import asyncio
import threading
import http.server
import socketserver
import imaplib
import smtplib
import email
import time
from email.mime.text import MIMEText
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq

# –ü–æ–ø—ã—Ç–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ WhatsApp (Green-API)
try:
    from whatsapp_api_client_python import API
    WA_AVAILABLE = True
except ImportError:
    WA_AVAILABLE = False

# --- 1. HEALTH CHECK –î–õ–Ø RENDER ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", port), handler) as httpd:
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- 2. –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

# WhatsApp (Green-API) - –ö–ª—é—á–∏ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
ID_INSTANCE = os.environ.get('WA_ID_INSTANCE')
API_TOKEN_INSTANCE = os.environ.get('WA_API_TOKEN')

# Gmail
EMAIL_USER = os.environ.get('EMAIL_USER')
EMAIL_PASS = os.environ.get('EMAIL_PASS')
EMAIL_IMAP = "imap.gmail.com"
EMAIL_SMTP = "smtp.gmail.com"

ai_client = Groq(api_key=GROQ_KEY)
tg_client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)

dialog_history = {}

# --- 3. –õ–û–ì–ò–ö–ê –ò –ü–†–û–ú–ü–¢–´ ---
WORK_KEYWORDS = ['—Ä—ã–±–∞–ª–∫–∞', 'fishing', '–¥–∏–∑–∞–π–Ω', '–ª–æ–≥–æ—Ç–∏–ø', '—Ç–∞–∫—Å–∏', '–∞—ç—Ä–æ–ø–æ—Ä—Ç']
GIRLS_KEYWORDS = ['—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é', '—Å–∫—É—á–Ω–æ', '–ø—Ä–æ–≥—É–ª–∫–∞', '—É–∂–∏–Ω', '–≤–µ—á–µ—Ä']

WORK_PROMPT = "–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: —Ä—ã–±–∞–ª–∫–∞, –¥–∏–∑–∞–π–Ω. –§—Ä–∞–∑–∞: '–ò—â—É –∑–∞—Ä–∞–±–æ—Ç–æ–∫ (–Ω—É–∂–Ω—ã –¥–µ–Ω—å–≥–∏)'."
GIRLS_PROMPT = "–¢—ã ‚Äî –≥–∞–ª–∞–Ω—Ç–Ω—ã–π –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è. –§—Ä–∞–∑–∞: '–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é —É—Å–ª—É–≥–∏ –Ω–∞ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–π –æ—Å–Ω–æ–≤–µ'."

async def get_ai_response(user_id, user_text):
    text_l = user_text.lower()
    is_girl = any(word in text_l for word in GIRLS_KEYWORDS)
    prompt = GIRLS_PROMPT if is_girl else WORK_PROMPT
    
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": prompt}]
    dialog_history[user_id].append({"role": "user", "content": user_text})
    
    try:
        completion = ai_client.chat.completions.create(model="llama3-8b-8192", messages=dialog_history[user_id])
        ai_text = completion.choices[0].message.content
        return ai_text, is_girl
    except:
        return "–ü—Ä–∏–≤–µ—Ç! –ì–æ—Ç–æ–≤ –æ–±—Å—É–¥–∏—Ç—å –¥–µ—Ç–∞–ª–∏, –ø–∏—à–∏—Ç–µ!", is_girl

# --- 4. –û–ë–†–ê–ë–û–¢–ß–ò–ö WHATSAPP (Green-API) ---
def wa_loop():
    if not WA_AVAILABLE or not ID_INSTANCE:
        print("‚ö†Ô∏è WhatsApp –ø—Ä–æ–ø—É—â–µ–Ω (–Ω–µ—Ç –∫–ª—é—á–µ–π –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏)")
        return
    
    wa_api = API.GreenApi(ID_INSTANCE, API_TOKEN_INSTANCE)
    print("üì≤ WhatsApp –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω")
    while True:
        try:
            receive = wa_api.receiving.receiveNotification()
            if receive.body:
                receipt_id = receive.body['receiptId']
                data = receive.body.get('messageData', {})
                chat_id = receive.body['senderData']['chatId']
                
                if 'textMessageData' in data:
                    text = data['textMessageData']['textMessage']
                    reply, _ = asyncio.run(get_ai_response(chat_id, text))
                    wa_api.sending.sendMessage(chat_id, reply)
                
                wa_api.receiving.deleteNotification(receipt_id)
        except:
            time.sleep(5)

# --- 5. –û–ë–†–ê–ë–û–¢–ß–ò–ö GMAIL ---
def email_loop():
    if not EMAIL_USER or not EMAIL_PASS:
        print("‚ö†Ô∏è –ü–æ—á—Ç–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞ (–Ω–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–∫)")
        return
        
    print("üìß Gmail –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω")
    while True:
        try:
            mail = imaplib.IMAP4_SSL(EMAIL_IMAP)
            mail.login(EMAIL_USER, EMAIL_PASS)
            mail.select("inbox")
            _, data = mail.search(None, 'UNSEEN')
            for num in data[0].split():
                _, msg_data = mail.fetch(num, '(RFC822)')
                msg = email.message_from_bytes(msg_data[0][1])
                sender = email.utils.parseaddr(msg['From'])[1]
                subject = msg['Subject'] or ""
                reply_text, _ = asyncio.run(get_ai_response(sender, subject))
                
                with smtplib.SMTP_SSL(EMAIL_SMTP, 465) as smtp:
                    smtp.login(EMAIL_USER, EMAIL_PASS)
                    resp = MIMEText(reply_text)
                    resp['Subject'] = "Re: " + subject
                    resp['To'] = sender
                    resp['From'] = EMAIL_USER
                    smtp.sendmail(EMAIL_USER, sender, resp.as_string())
        except:
            time.sleep(30)

# --- 6. –û–ë–†–ê–ë–û–¢–ß–ò–ö TELEGRAM ---
@tg_client.on(events.NewMessage)
async def handle_tg(event):
    if event.out: return
    try:
        sender = await event.get_sender()
        reply, is_girl = await get_ai_response(sender.id, event.raw_text)
        await asyncio.sleep(2)
        await event.respond(reply)
        
        tag = "üíé VIP (TG)" if is_girl else "üõ† –ó–ê–ö–ê–ó (TG)"
        await tg_client.send_message('me', f"üî• **{tag}**\nüë§: {sender.first_name}\nüí¨: {event.raw_text}")
    except telethon.errors.rpcerrorlist.SlowModeWaitError:
        print("‚ö†Ô∏è –í —á–∞—Ç–µ –º–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º, –ø—Ä–æ–ø—É—Å–∫–∞—é...")
    except Exception as e:
        print(f"–û—à–∏–±–æ—á–∫–∞: {e}")

# --- 7. –ó–ê–ü–£–°–ö ---
if __name__ == '__main__':
    threading.Thread(target=wa_loop, daemon=True).start()
    threading.Thread(target=email_loop, daemon=True).start()
    print("üöÄ –ë–û–¢ –ó–ê–ü–£–°–ö–ê–ï–¢–°–Ø...")
    tg_client.start()
    tg_client.run_until_disconnected()
