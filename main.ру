import os
import asyncio
import threading
import http.server
import socketserver
import imaplib
import smtplib
import email
import time
from email.mime.text import MIMEText
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from groq import Groq
from pywa import WhatsApp

# --- 1. HEALTH CHECK –î–õ–Ø RENDER (–ß–¢–û–ë–´ –ù–ï –ë–´–õ–û TIMED OUT) ---
def run_health_check():
    port = int(os.environ.get("PORT", 8080))
    handler = http.server.SimpleHTTPRequestHandler
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", port), handler) as httpd:
        print(f"‚úÖ Render port {port} is active")
        httpd.serve_forever()

threading.Thread(target=run_health_check, daemon=True).start()

# --- 2. –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
API_ID = 30893125
API_HASH = '5c73de68f3152f0513292cb495071e0b'
SESSION_STR = os.environ.get('TELEGRAM_STRING_SESSION')
GROQ_KEY = os.environ.get('GROQ_API_KEY')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ WhatsApp –∏ Email –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
WA_PHONE_ID = os.environ.get('WA_PHONE_ID')
WA_TOKEN = os.environ.get('WA_TOKEN')
EMAIL_USER = os.environ.get('EMAIL_USER')
EMAIL_PASS = os.environ.get('EMAIL_PASS')
EMAIL_IMAP = "imap.gmail.com"

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–æ–≤
ai_client = Groq(api_key=GROQ_KEY)
tg_client = TelegramClient(StringSession(SESSION_STR), API_ID, API_HASH)
wa_client = WhatsApp(phone_id=WA_PHONE_ID, token=WA_TOKEN)

dialog_history = {}

# --- 3. –õ–û–ì–ò–ö–ê –ò –ü–†–û–ú–ü–¢–´ –î–õ–Ø GROQ ---
WORK_KEYWORDS = ['—Ä—ã–±–∞–ª–∫–∞', 'fishing', '–¥–∏–∑–∞–π–Ω', '–ª–æ–≥–æ—Ç–∏–ø', '—Ç–∞–∫—Å–∏', '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–±–∫–∫']
GIRLS_KEYWORDS = ['—Å–æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–ø–∞–Ω–∏—é', '—Å–∫—É—á–Ω–æ', '–∏—â—É –ø–∞—Ä–Ω—è', '–ø—Ä–æ–≥—É–ª–∫–∞', '—É–∂–∏–Ω', '–≤–µ—á–µ—Ä', '–∫–æ–º–ø–∞–Ω–∏—è']
BAD_WORDS = ['–∫—Ä–∏–ø—Ç–∞', '–æ–±–º–µ–Ω', '–≤–∞–ª—é—Ç–∞', '–∞—Ä–±–∏—Ç—Ä–∞–∂', '—Ç—Ä–∞—Ñ–∏–∫']

WORK_PROMPT = "–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: —Ä—ã–±–∞–ª–∫–∞, –¥–∏–∑–∞–π–Ω, —Ç–∞–∫—Å–∏. –§—Ä–∞–∑–∞: '–ò—â—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∑–∞—Ä–∞–±–æ—Ç–∫–∞ (–Ω—É–∂–Ω—ã –¥–µ–Ω—å–≥–∏)'. –ö—Ä–∞—Ç–∫–æ."
GIRLS_PROMPT = "–¢—ã ‚Äî –≥–∞–ª–∞–Ω—Ç–Ω—ã–π —Å–ø—É—Ç–Ω–∏–∫ –ê–∞—Ä–æ–Ω. –£—Å–ª—É–≥–∏: —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ –¥–ª—è –¥–∞–º, —É–∂–∏–Ω, –ø—Ä–æ–≥—É–ª–∫–∏. –§—Ä–∞–∑–∞: '–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é —É—Å–ª—É–≥–∏ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è –Ω–∞ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–π –æ—Å–Ω–æ–≤–µ (—Ü–µ–Ω—é —Å–≤–æ–µ –≤—Ä–µ–º—è –∏ –≤–∞—à –∫–æ–º—Ñ–æ—Ä—Ç)'. –°—Ç–∏–ª—å: —Ö–∞—Ä–∏–∑–º–∞—Ç–∏—á–Ω—ã–π."

async def get_ai_response(user_id, user_text):
    text_l = user_text.lower()
    is_girl = any(word in text_l for word in GIRLS_KEYWORDS)
    prompt = GIRLS_PROMPT if is_girl else WORK_PROMPT
    
    if user_id not in dialog_history:
        dialog_history[user_id] = [{"role": "system", "content": prompt}]
    
    dialog_history[user_id].append({"role": "user", "content": user_text})
    
    try:
        completion = ai_client.chat.completions.create(
            model="llama3-8b-8192", 
            messages=dialog_history[user_id]
        )
        ai_text = completion.choices[0].message.content
        dialog_history[user_id].append({"role": "assistant", "content": ai_text})
        return ai_text, is_girl
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ Groq: {e}")
        return "–ò—â—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∑–∞—Ä–∞–±–æ—Ç–∫–∞, –≥–æ—Ç–æ–≤ –æ–±—Å—É–¥–∏—Ç—å!", False

# --- 4. –û–ë–†–ê–ë–û–¢–ß–ò–ö EMAIL ---
def email_loop():
    while True:
        try:
            mail = imaplib.IMAP4_SSL(EMAIL_IMAP)
            mail.login(EMAIL_USER, EMAIL_PASS)
            mail.select("inbox")
            _, data = mail.search(None, 'UNSEEN')
            
            for num in data[0].split():
                _, msg_data = mail.fetch(num, '(RFC822)')
                msg = email.message_from_bytes(msg_data[0][1])
                sender = email.utils.parseaddr(msg['From'])[1]
                subject = msg['Subject'] or ""
                
                reply_text, _ = asyncio.run(get_ai_response(sender, subject))
                
                # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
                with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
                    smtp.login(EMAIL_USER, EMAIL_PASS)
                    resp = MIMEText(reply_text)
                    resp['Subject'] = "Re: " + subject
                    resp['To'] = sender
                    smtp.sendmail(EMAIL_USER, sender, resp.as_string())
        except:
            pass
        time.sleep(30)

# --- 5. –û–ë–†–ê–ë–û–¢–ß–ò–ö TELEGRAM ---
@tg_client.on(events.NewMessage)
async def handle_tg(event):
    if event.out: return
    sender = await event.get_sender()
    if not sender: return
    
    text = event.raw_text.lower()
    if any(bad in text for bad in BAD_WORDS): return

    if event.is_private or any(word in text for word in WORK_KEYWORDS + GIRLS_KEYWORDS):
        reply, is_girl = await get_ai_response(sender.id, event.raw_text)
        await asyncio.sleep(2)
        await event.respond(reply)
        
        # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–µ
        tag = "üíé VIP (TG)" if is_girl else "üõ† –ó–ê–ö–ê–ó (TG)"
        user_link = f"https://t.me/{sender.username}" if getattr(sender, 'username', None) else f"ID: {sender.id}"
        await tg_client.send_message('me', f"üî• **{tag}**\nüë§: {sender.first_name}\nüí¨: {event.raw_text}\nüîó: {user_link}")

# --- 6. –û–ë–†–ê–ë–û–¢–ß–ò–ö WHATSAPP ---
@wa_client.on_message()
def handle_wa(client, msg):
    reply, _ = asyncio.run(get_ai_response(msg.from_user.wa_id, msg.text))
    msg.reply_text(reply)

# --- 7. –ó–ê–ü–£–°–ö –í–°–ï–ì–û ---
async def start_bot():
    await tg_client.start()
    print("üöÄ –°–£–ü–ï–†-–ë–û–¢ –ê–ê–†–û–ù–ê –ó–ê–ü–£–©–ï–ù (TG + WA + EMAIL)")
    await tg_client.run_until_disconnected()

if __name__ == '__main__':
    threading.Thread(target=email_loop, daemon=True).start()
    # WhatsApp –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Å–≤–æ–∏–º –º–µ—Ç–æ–¥–æ–º, –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω webhook, –∏–Ω–∞—á–µ –ø–æ—Ç–æ–∫–æ–º
    if WA_TOKEN:
        threading.Thread(target=wa_client.run, daemon=True).start()
    
    asyncio.run(start_bot())
